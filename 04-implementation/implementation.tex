\documentclass[../report.tex]{subfiles}

\begin{document}

\chapter{\writingNotes{Implementation}} \label{cha:implementation}

% - Choice of rust
% - Parameters
% - Messages exchanges
%   - Register
%   - Login
% - Function definition (API)
%   - Client
%   - Server
% - Messages struct
% - Choice of libraries
%   - dalek + PR
%   - voprf
%   - hkdf
%   - argon2
% - Others
%   - Rejection method
%   - Elligator element encoding
%   - Serialization
%   - Discharge password from memory directly after use

This chapter define specific implementation details for the KHAPE library \footnote{KHAPE's library implementation is available here : https://github.com/jul0105/KHAPE}.

\section{Parameters}
Both the client and the server has to define their parameters. For a client and a server to authenticate, they need to have the same parameters. 
Generally parameters are fixed by the application developer and are the same for every clients of the application.
They can also be negotiated during registration but this require the server to store each client specific parameters as it can be different. This use case is not in the scope of the KHAPE library.

\paragraph{OPRF}
It is strongly encouraged to use the OPRF.
It provide an higher security level (see Section \ref{sec:opaque_oprf}) without impacting too much on the performances (see Section \ref{sec:oprf_performances}).


\paragraph{Slow Hash}
It is also encouraged to use a Slow Hash function. It allows to be more resistant against attacker (see Section \ref{sec:password_hardening_comparison} but it has a high impact on the performances (see Section \ref{sec:slowhash_performances}).

Overall, it is strongly discouraged to use neither of them because this mean that the credentials envelope is encrypted by a weak key resulting only of an HKDF of the low-entropy password.


\section{Exchanges}

This section shows which function is called to produce each messages during the exchange between the client and the server for both registration and authentication

\subsection{Registration}
\begin{verbatim}
Client                                                           Server
-----------------------------------------------------------------------
(register_request, oprf_client_state) = client.register_start(password);

----------------register_request----------------->

(register_response, pre_register_secrets) 
    = server.register_start(register_request);

<-----------------register_request----------------

register_finish
    = client.register_finish(register_response, oprf_client_state);

----------------register_finish----------------->

file_entry = server.register_finish(register_finish, pre_register_secrets)

                                                store file_entry
\end{verbatim}
\subsection{Authentication}
\begin{verbatim}
(auth_request, oprf_client_state) = client.auth_start(password)
----------------auth_request----------------->
(auth_response, server_ephemeral_keys) 
    = server.auth_start(auth_request, &file_entry)
<-----------------auth_response----------------
(auth_verify_request, ke_output) 
    = client.auth_ke(auth_response, oprf_client_state)
----------------auth_verify_request----------------->
(auth_verify_response, server_output_key) 
    = server.auth_finish(auth_verify_request, server_ephemeral_keys,
                         &file_entry)
<-----------------auth_verify_response----------------
client_output_key = client.auth_finish(auth_verify_response, ke_output)
\end{verbatim}


\section{Function definition} \label{sec:impl_function_def}

This section shows the client and the server API.
For each function, the operations executed are listed.


\subsection{Client}
\begin{itemize}
 \item \verb|register_start(Password) -> (RegisterRequest, ClientState)|
  \begin{enumerate}
    \item Compute OPRF initialization (optional)
    \item Build \verb|RegisterRequest| with uid and OPRF blinded result
    \item Build \verb|ClientState| with OPRF state
  \end{enumerate}
  
 \item \verb|register_finish(RegisterResponse, ClientState) -> (RegisterFinish, ExportKey)|
  \begin{enumerate}
    \item Generate asymmetric key pair
    \item Compute OPRF output (optional)
    \item Compute slow hash (optional)
    \item Derive encryption key and export key
    \item Encrypt envelope containing private key and server's public key
    \item Build \verb|RegisterFinish| with envelope ciphertext and own public key
  \end{enumerate}
 
 
 
 \item \verb|auth_start(Password) -> (AuthRequest, ClientState)|
   \begin{enumerate}
    \item Compute OPRF initialization (optional)
    \item Build \verb|RegisterRequest| with uid and OPRF blinded result
    \item Build \verb|ClientState| with OPRF state
  \end{enumerate}
  
 \item \verb|auth_ke(AuthResponse, ClientState) -> (AuthVerifyRequest,|\\
       \verb| KeyExchangeOutput, ExportKey)|
  \begin{enumerate}
    \item Generate ephemeral asymmetric key pair
    \item Compute OPRF output (optional)
    \item Compute slow hash (optional)
    \item Derive encryption key and export key
    \item Decrypt envelope containing private key and server's public key
    \item Compute key exchange output
    \item Build \verb|AuthVerifyRequest| with uid, verify tag and ephemeral public key
  \end{enumerate}
 
 \item \verb|auth_finish(AuthVerifyResponse, KeyExchangeOutput)|\\
       \verb| -> Option<OutputKey>|
  \begin{enumerate}
    \item Verify server's verification tag
    \item Return output key
  \end{enumerate}
  
\end{itemize}

\subsection{Server}
\begin{itemize}
 \item \verb|register_start(RegisterRequest) -> (RegisterResponse,|\\
       \verb| PreRegisterSecrets)|
  \begin{enumerate}
    \item Generate asymmetric key pair
    \item Generate OPRF secret salt (optional)
    \item Compute OPRF evaluation with secret salt (optional)
    \item Build \verb|RegisterResponse| with public key and OPRF evaluation
    \item Build \verb|PreRegisterSecret| with private key and OPRF secret salt
  \end{enumerate}
  
 \item \verb|register_finish(RegisterFinish, PreRegisterSecrets) -> FileEntry|
  \begin{enumerate}
    \item Build storable \verb|FileEntry| structure with encrypted envelope, server's private key, client's public key and OPRF secret salt
  \end{enumerate}
  
  
  
 \item \verb|auth_start(AuthRequest, FileEntry) -> (AuthResponse, EphemeralKeys)|
  \begin{enumerate}
    \item Generate ephemeral asymmetric key pair
    \item Retrieve encrypted envelope and OPRF secret salt from file entry
    \item Compute OPRF evaluation with secret salt (optional)
    \item Build \verb|AuthResponse| with encrypted envelope, ephemeral public key and OPRF evaluation
    \item Build \verb|EphemeralKeys| with ephemeral key pair
  \end{enumerate}
  
 \item \verb|auth_finish(AuthVerifyRequest, EphemeralKeys, FileEntry)|\\ 
       \verb| -> (AuthVerifyResponse, Option<OutputKey>)|
  \begin{enumerate}
    \item Retrieve server's private key and client's public key from file entry
    \item Compute key exchange output
    \item Verify client's verification tag
    \item Build \verb|AuthVerifyResponse| with own verification tag
    \item Return output key
  \end{enumerate}
  
\end{itemize}


% \section{Messages structures}
% 
% 
% \begin{verbatim}
% pub struct RegisterRequest {
%     pub uid: String,
%     pub(crate) oprf_client_blind_result: Option<Vec<u8>>,
% }
% 
% pub struct RegisterResponse {
%     pub(crate) pub_b: PublicKey,
%     pub(crate) oprf_server_evalute_result: Option<Vec<u8>>,
% }
% 
% pub struct RegisterFinish {
%     pub uid: String,
%     pub(crate) encrypted_envelope: EncryptedEnvelope,
%     pub(crate) pub_a: PublicKey
% }
% 
% 
% pub struct AuthRequest {
%     pub uid: String,
%     // pub sid: String, // TODO sid
%     pub(crate) oprf_client_blind_result: Option<Vec<u8>>,
% }
% 
% 
% pub struct AuthResponse {
%     pub(crate) encrypted_envelope: EncryptedEnvelope,
%     pub(crate) pub_y: PublicKey,
%     pub(crate) oprf_server_evalute_result: Option<Vec<u8>>,
% }
% 
% 
% pub struct AuthVerifyRequest {
%     pub uid: String,
%     // pub sid: String, // TODO sid
%     pub(crate) client_verify_tag: VerifyTag,
%     pub(crate) pub_x: PublicKey,
% }
% 
% 
% pub struct AuthVerifyResponse {
%     pub(crate) server_verify_tag: Option<VerifyTag>,
% }
% \end{verbatim}

% TODO server storage struct, client state, envelope ?


\section{Library choices}

This section shows the dependencies to implement the KHAPE library and the choice of using them.

\begin{itemize}
 \item \verb|curve25519-dalek v3.2.0| : Pure rust implementation of group operations on Ristretto and Curve25519. Audited in 2019 \cite{https://blog.quarkslab.com/security-audit-of-dalek-libraries.html}. Patched with PR \cite{https://github.com/dalek-cryptography/curve25519-dalek/pull/357} to implement elligator\_decode
 \item \verb|voprf v0.3| : Implementation of a verifiable OPRF based on the standard draft \cite{VOPRF_Standard_Draft}.
 \item \verb|sha3 v0.9| : Pure rust implementation of the SHA-3 (Keccak) hash function
 \item \verb|hkdf v0.11| : Pure rust implementation of the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) generic over hash function
 \item \verb|argon2 v0.3| : Pure rust implementation of the Argon2 password hashing function
\item \verb|rand v0.8| : Random number generators
 \item \verb|serde v1| : Framework for serializing and deserializing Rust data structures efficiently and generically
%  \item \verb|serde_json v1| : JSON serialization file format
 \item \verb|serde-big-array v0.3| : Big array helper for serde
\end{itemize}




% \section{Interesting functions}
% \subsection{Rejection method}
% \subsection{Elligator element encoding}


\end{document}

