\documentclass[../report.tex]{subfiles}

\begin{document}

\chapter{\writingNotes{Implementation}}
\section{API}
\subsection{Parameters}
Both client and server has to define their parameters. For a client and a server to authenticate, they need to have the same parameters. 
Generally parameters are fixed by the application developer and are the same for every clients of the application.
They can also be negotiated during registration but this require the server to store each client specific parameters as it can be different. This use case is not in the scope of the KHAPE library.

\paragraph{OPRF}
Strongly encouraged, improve security by a lot, doesn't take much time/resource.
\paragraph{Slow Hash}
Encouraged, improve security, take lot of time and resources

Overall, it is strongly discouraged to use neither of them because this mean that the credentials envelope is encrypted by a weak key resulting only of an HKDF of the low-entropy password.


\subsection{Client}
\subsection{Server}
\subsection{Messages}
% Parameters, Client, Server and Messages

\subsection{Common}
\begin{itemize}
 \item \verb|generate_asymetric_key|
    % generate a in Zp
    % compute A
    % return (a, A)
\end{itemize}


\subsection{Client register}
\begin{itemize}
 \item \verb|client_register_start(uid, pw): RegisterRequest|
    % compute OPRF initialization
    % add OPRF h1 and uid to a struct
    % return struct
 \item \emph{Sends uid and h1. Receive B and h2}
 \item \verb|client_register_finish(B, pw, h2) : e|
    % generate_asymetric_key
    % compute OPRF output
    % encrypt (a, B) with rw
    % return ciphertext
 \item \emph{Sends e and A}
\end{itemize}


\subsection{Server register}
\begin{itemize}
 \item \emph{Receive uid and h1}
 \item \verb|server_register_start(uid, h1): (b, B, salt, h2)|
    % generate_asymetric_key
    % generate OPRF salt
    % compute OPRF h2
    % return B and h2 % TODO how to store salt and b (secret) ? Pre-store b and salt in file[uid] (remove it on server_register_finish) OR use a session_file[sid] <- (b, salt)
 \item \emph{Response B and h2}
 \item \emph{Receive e and A}
 \item \verb|server_register_finish(e, A, b, salt): file_entry|
    % store (e, b, A, salt) 
\end{itemize}



\subsection{Client login}
\begin{itemize}
 \item \verb|client_auth_start(uid, pw): RegisterRequest| % similar to client_register_start
    % compute OPRF initialization 
    % add OPRF h1 and uid to a struct
    % return struct
 \item \emph{Sends uid and h1. Receive e, Y and h2}
 \item \verb|client_auth_ke(e, Y, h2, r, pw) : (k1, t1, X)|
    % generate_asymetric_key
    % compute OPRF output
    % decrypt (a, B) with rw
    % compute KeyHidingAKE
    % compute k1 and t1 % TODO sid, C, S ?
    % return k1, t1 and X
 \item \emph{Sends t1 and X. Receive t2}
 \item \verb|client_auth_finish(t2, k1) : K1|
    % verify t2
    % compute K1
    % return K1

\end{itemize}


\subsection{Server login}
\begin{itemize}
 \item \emph{Receive uid and h1}
 \item \verb|server_auth_start(uid, h1, file): (e, Y, h2)|
    % generate_asymetric_key
    % retrieve (e, salt) from file
    % compute OPRF h2 % TODO ensure that client-side attacker cannot retrieve salt (by inputing anoter user uid)
    % return e, Y, y, h2 % TODO how to store y ? Store in file[uid] (remove it on server_auth_finish) OR use a session_file[sid] <- (y)
 \item \emph{Response e, Y and h2}
 \item \emph{Receive t1 and X}
 \item \verb|server_auth_finish(X, Y, A, y, b, t1, file): (K2, t2)|
    % retrieve (b, A) from file
    % compute KeyHidingAKE
    % compute k2 % TODO sid, C, S ?
    % verify t1
    % compute t2 and K2
    % return K2, t2 % TODO what to do with K2 (session key) ? Store in db ? Expiration ? use a session_file[sid] <- K
 \item \emph{Response t2}

\end{itemize}

\subsection{Structure}
Ciphersuite
file

\section{Dependencies/Libraries choices}
\begin{itemize}
 \item OPRF : https://crates.io/crates/voprf
 \item Curve : https://crates.io/crates/curve25519-dalek (Support Elligator2)
\end{itemize}

\section{Code structure}
\section{Interesting functions}
\subsection{Discharge password from RAM directly after use}
\subsection{(Timing attack mitigation)}
\end{document}

