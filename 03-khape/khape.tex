\documentclass[../report.tex]{subfiles}


\begin{document}

\chapter{\writingNotes{KHAPE}}

This chapter explain the details of the KHAPE protocol in term of implementation and explain the design choices.

\section{Choice of implementing KHAPE}

The choice is based on the properties of the PAKE and the existence of implementations and/or standard for this PAKE.

OPAQUE and KHAPE provide the highest level of security amongst aPAKE protocols.
But while OPAQUE is becoming more mature with a draft standard and multiple high-quality implementations --- including in rust \ref{opaque-ke}, KHAPE is still very recent.
In fact, KHAPE paper was published only 6 month ago at the time of the writing. To my knowledge, there is currently no public implementation of KHAPE and this is why I will be implementing it.

\section{Generic algorithm}
This sections details a generic KHAPE protocol.
Algorithm \ref{alg:login_client} and \ref{alg:login_server} show the pseudocode of a login process from both client-side and server-side. Algorithm \ref{alg:register_client} and \ref{alg:register_server} show the register process.


\begin{algorithm}[h]
\caption{KHAPE : Authentication on the client (generic algorithm)}
\label{alg:login_client}
\begin{algorithmic}
\Require Knows username \verb|uid| and password $pw$
\If {OPRF}
    \State $r \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
    \State $h_1 \gets$ HashToGroup($pw$)$^r$
    \State Sends authentication request to the server with \verb|uid| and $h_1$
\Else
    \State Sends authentication request to the server with \verb|uid|
\EndIf
% C on (CltSession; sid; S; pw) ??
\State $x \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $X \gets g^x$

\If {OPRF}
    \State Wait to receive $e$, $Y$ and $h_2$ from the server
    \State $salt_2 \gets$ $h_2^{\frac{1}{r}}$
    \State $rw \gets$ Hash($salt_2$, $pw$)
    \State $(a, B) \gets$ Decrypt($rw$, $e$)
\Else
    \State Wait to receive $e$ and $Y$ from the server
    \State $(a, B) \gets$ Decrypt($pw$, $e$)
\EndIf

% HMQV :
% \State $d_c \gets$ Hash'(sid, C, S, 1, $X$)
% \State $e_c \gets$ Hash'(sid, C, S, 2, $Y$)
% \State $o_c \gets (Y \cdot B^{e_c})^{x+d_c \cdot a}$

% 3DH :
% \State $o_c \gets B^x || Y^a || Y^x$

% Generic
\State $o_c \gets$ KeyHidingAKE($X$, $Y$, $B$, $x$, $a$)

\State $k_1 \gets$ Hash(sid, C, S, $X$, $Y$, $o_c$)
\State $t_1 \gets$ PRF($k_1$, 1)
\State Sends $t_1$ and $X$ to the server


\State Wait to receive $t_2$ from the server
\If {$t_2 \neq$ PRF($k_1$, 2)}
    \State $K_1 \gets$ False
\Else
    \State $K_1 \gets$ PRF($k_1$, 0)
\EndIf

\State output $K_1$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{KHAPE : Authentication on the server (generic algorithm)}
\label{alg:login_server}
\begin{algorithmic}
\Require Store password file $file$ containing <$e$, $b$, $A$[, $salt$]>
\If {OPRF}
    \State Wait to receive authentication request from the client with \verb|uid| and $h_1$
\Else
    \State Wait to receive authentication request from the client with \verb|uid|
\EndIf

% S on (SvrSession; sid; C; uid)
\State $y \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $Y \gets g^y$

\If {OPRF}
    \State ($e$, $b$, $A$, $salt$) $\gets$ file[\verb|uid|, S] % TODO S ?
    \State $h_2 \gets h_1^{salt}$
    \State Sends $e$, $Y$ and $h_2$ to the client
\Else
    \State ($e$, $b$, $A$) $\gets$ file[\verb|uid|, S] % TODO S ?
    \State Sends $e$ and $Y$ to the client
\EndIf


\State Wait to receive $t_1$ and $X$ from the client

% 3DH :
% \State $o_s \gets X^b || A^y || X^y$

% Generic
\State $o_s \gets$ KeyHidingAKE($X$, $Y$, $A$, $y$, $b$)

\State $k_2 \gets$ Hash(sid, C, S, $X$, $Y$, $o_s$)


\If {$t_1 \neq$ PRF($k_2$, 1)}
    \State $t_2 \gets$ False
\Else
    \State $t_2 \gets$ PRF($k_2$, 2)
\EndIf


\State Sends $t_2$ to the client


\If {$t_1 \neq$ PRF($k_2$, 1)}
    \State $K_2 \gets$ False
\Else
    \State $K_2 \gets$ PRF($k_2$, 0)
\EndIf

\State output $K_2$
\end{algorithmic}
\end{algorithm}

% Notes:
% - x, y : ephemeral sessions secrets
% - a, b : long-term keys
% - d, e :  hashes of (session state identifiers and) resp. X = g^x and Y = g^y.

% To understand :
% - sid = Session identifiers (generated randomly for a new session)
% - uid = user id ?
% - C, S = each party identity ?? ("These identities could be e.g. domain names, user names, or any other identifiers. They have no other semantics except that the two parties can establish the same session key only if they assume matching identifiers, i.e. (P1; CP1) = (CP2; P2)")
% - CltSession
% - SvrSession


% TODO generate sid
% TODO C and S ?


\begin{algorithm}
\caption{KHAPE : Registration on the client (generic algorithm)}
\label{alg:register_client}
\begin{algorithmic}
\Require Choose username \verb|uid| and password $pw$

\If {OPRF}
    \State $r \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
    \State $h_1 \gets$ HashToGroup($pw$)$^r$
    \State Sends registration request to the server with \verb|uid| and $h_1$
\Else
    \State Sends registration request to the server with \verb|uid|
\EndIf

\State $a \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $A \gets g^a$

\If {OPRF}
    \State Wait to receive $B$ and $h_2$ from the server
    \State $salt_2 \gets$ $h_2^{\frac{1}{r}}$
    \State $rw \gets$ Hash($salt_2$, $pw$)
    \State $e \gets$ Encrypt($rw$, $(a, B)$)
\Else
    \State Wait to receive $B$ from the server
    \State $e \gets$ Encrypt($pw$, $(a, B)$)
\EndIf

\State Sends $e$ and $A$ to the server


\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{KHAPE : Registration on the server (generic algorithm)}
\label{alg:register_server}
\begin{algorithmic}
\Require 

\If {OPRF}
    \State Waits to receive registration request from a client with \verb|uid| and $h_1$
\Else
    \State Waits to receive registration request from a client with \verb|uid|
\EndIf

\State $b \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $B \gets g^b$

\If {OPRF}
    \State $salt \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
    \State $h_2 \gets h_1^{salt}$    
    \State Sends $B$ and $h_2$ to the client
\Else
    \State Sends $B$ to the client
\EndIf

\State Waits to receive $e$ and $A$ from the client

\If {OPRF}
    \State Store file[\verb|uid|, S] $\gets$ ($e$, $b$, $A$, $salt$) % TODO S ?
\Else
    \State Store file[\verb|uid|, S] $\gets$ ($e$, $b$, $A$) % TODO S ?
\EndIf

\end{algorithmic}
\end{algorithm}




\section{\writingFormulationBrut{Design choices}}

This section explain the design choices made to implement KHAPE.
Since the only resource for KHAPE is the rather theoretical paper, lots of design choice have to be made. However, since OPAQUE and KHAPE share similarities, some implementation choices are inspired by the OPAQUE standard draft whenever it's possible.


\subsection{\writingFormulationBrut{Client-side register}}
Both client-side and server-side registration are possible but in order to use the aPAKE benefit to the fullest, it is preferable to handle the registration on the client.

This allow to keep the main goal of aPAKEs: the server NEVER see the user's password.

\subsection{Group $\mathbb{G}$}


KHAPE constructions are defined on a group $\mathbb{G}$ of prime order $p$ with generator $g$.
The group is generic which means we are free to use an integer group or an elliptic curves group.
% p in KHAPE = q in CRY
% p in CRY is not defined in KHAPE because it's generic (integer or ECC) (no modulo in ECC)

For performances reasons, ECC will be used.
The curve must be compatible with the curve encoding algorithm selected (Elligator-squared, Elligator2, etc.).

Represented on 256 bits (which curve ?)


\subsection{\writingFormulationBrut{OPRF}}
In KHAPE, the OPRF is optional --- in contrary to OPAQUE --- but allow to make it a strong aPAKE resistant against pre-computation attacks.

This is a major improvement in term of security and therefore an OPRF should be used.


\subsection{\writingFormulationBrut{Key Exchange}}
KHAPE require that the underlying Authenticated Key Exchange (AKE) is a key-hiding AKE.
\cite{KHAPE_Paper} shows that HMQV, 3DH and SKEME are key-hiding AKE.

SKEME is a AKE based on key encryption mechanism where HMQV and 3DH are Diffie-Hellman based AKE.
\cite{OPAQUE_Paper} and \cite{KHAPE_Paper} shows concrete instantiation of their protocol using HMQV. These instantiations are easily adapted to other Diffie-Hellman based AKE like 3DH.

HMQV :
\begin{algorithmic}
 % HMQV :
\State $d_c \gets$ Hash'(sid, C, S, 1, $X$)
\State $e_c \gets$ Hash'(sid, C, S, 2, $Y$)
\State $o_c \gets (Y \cdot B^{e_c})^{x+d_c \cdot a}$
\end{algorithmic}

3DH :
\begin{algorithmic}
% 3DH :
\State $o_c \gets B^x || Y^a || Y^x$
\end{algorithmic}

Between HMQV and 3DH, HMQV is more efficient but it is patented. This is why 3DH is used for the implementation.

\subsection{\writingNotes{Encryption schema}}
non-commiting encryption: elligator2 + ideal cipher

input range between 512 and 1024 bits depending on envelope size


In contrary to the OPAQUE Paper, the OPAQUE standard draft doesn't encrypt the client's private key in the envelope.
Instead, the envelope store a nonce of 32 bytes and an authentication tag. The envelope is not encrypted.
The nonce is used --- with the randomized password --- to compute a seed, which is then used to derive the client's private and public keys. The authentication tag stored in the envelope is used to verify the derived public key.


\subsection{\writingFormulationBrut{Slow Hash}}
It is possible and recommended to use a memory-hard hashing function on the password to make it slow and expensive to compute. 
This make it more costly for an adversary to compute hashs.

For the implementation, Argon2 is used because it is a recent memory-hard hashing function with a simple construction and it has better security analysis than others KDF like scrypt, bcrypt and PBKDF2 \cite{CAA}.

For OPAQUE, \cite{OPAQUE_Standard_Draft} propose to implement this function on the OPRF output $rw$ and use the result to derive the encryption key.


\subsection{\writingFormulationBrut{Key derivation}}

This section describe the derivation of keys from secrets. It is heavily inspired by OPAQUE's standard draft \cite{OPAQUE_Standard_Draft} since the context is similar.



\subsubsection{Encryption key and export key}


\begin{verbatim}
hardened_output = SlowHash(oprf_output, params)
randomized_pwd = Extract(salt="", ikm=concat(oprf_output, hardened_output))

encryption_key = Expand(randomized_pwd, concat(envelope_nonce, "EncryptionKey"), Nh)
export_key = Expand(randomized_pwd, concat(envelope_nonce, "ExportKey"), Nh)


ikm := input keying material
\end{verbatim}




\begin{verbatim}
1. y = Finalize(password, blind, response.data, nil)
2. randomized_pwd = Extract("", concat(y, Harden(y, params)))
\end{verbatim}


\begin{verbatim}
2. masking_key = Expand(randomized_pwd, "MaskingKey", Nh)
3. auth_key = Expand(randomized_pwd, concat(envelope_nonce, "AuthKey"), Nh)
4. export_key = Expand(randomized_pwd, concat(envelope_nonce, "ExportKey"), Nh)
5. seed = Expand(randomized_pwd, concat(envelope_nonce, "PrivateKey"), Nseed)
\end{verbatim}


\subsubsection{Output key and key verification}

\begin{verbatim}
DeriveKeys(ikm, preamble)

Input:
- ikm, input key material.
- preamble, the protocol transcript with identities and messages.

Output:
- Km2, a MAC authentication key.
- Km3, a MAC authentication key.
- session_key, the shared session secret.

Steps:
1. prk = Extract("", ikm)
2. handshake_secret = Derive-Secret(prk, "HandshakeSecret", Hash(preamble))
3. session_key = Derive-Secret(prk, "SessionKey", Hash(preamble))
4. Km2 = Derive-Secret(handshake_secret, "ServerMAC", "")
5. Km3 = Derive-Secret(handshake_secret, "ClientMAC", "")
6. Output (Km2, Km3, session_key)
\end{verbatim}


\subsection{Hash}
Sha3-256

\subsection{HashToGroup}
Operation of hashing to the group. Since we use elliptic curves, this operation is an hash-to-curve.


\subsection{PRF}
HKDF

\subsection{Session during authentication or registration ?}


\subsection{GenerateRandomNumber}
Voir CAA





\section{Security consideration}

\subsection{Difference with OPAQUE} %TODO put this section somewhere (in state-of-the-art ?)

Verification must be initialized by the client, this mean that protocol in completed with 4 message instead of 3 for OPAQUE.
Still use encryption (ideal cipher) where the OPAQUE standard draft doesn't use encryption anymore.
Use key-hiding AKE (3DH and HMQV are key-hiding AKE so this doesn't change anything).

% see OPAQUE standard chapter 10
\subsection{Input validation}
``We assume that parties verify public keys and ephemeral DH values, resp.
B; Y for P1 and A; X for P2, as group G elements.''

\subsection{SlowHash}
Optionaly, use Argon2, scrypt, etc. on the password before inputting it in the algo


\section{Precise algorithm}

\section{(Threat model)}



\end{document}

