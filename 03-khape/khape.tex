\documentclass[../report.tex]{subfiles}


\begin{document}

\chapter{\writingNotes{KHAPE}}

This chapter explain the details of the KHAPE protocol in term of implementation and explain the design choices.

\section{Choice of implementing KHAPE}

The choice is based on the properties of the PAKE and the existence of implementations and/or standard for this PAKE.

OPAQUE and KHAPE provide the highest level of security amongst aPAKE protocols.
But while OPAQUE is becoming more mature with a draft standard and multiple high-quality implementations --- including in rust \ref{opaque-ke}, KHAPE is still very recent.
In fact, KHAPE paper was published only 6 month ago at the time of the writing. To my knowledge, there is currently no public implementation of KHAPE and this is why I will be implementing it.

\section{Generic algorithm} \label{sec:khape_generic_algo}
This sections details a generic KHAPE protocol.
Algorithm \ref{alg:login_client} and \ref{alg:login_server} show the pseudocode of a login process from both client-side and server-side. Algorithm \ref{alg:register_client} and \ref{alg:register_server} show the register process.


\begin{algorithm}[h]
\caption{KHAPE : Authentication on the client (generic algorithm)}
\label{alg:login_client}
\begin{algorithmic}
\Require Knows username \verb|uid| and password $pw$
\If {OPRF}
    \State $r \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
    \State $h_1 \gets$ HashToGroup($pw$)$^r$
    \State Sends authentication request to the server with \verb|uid| and $h_1$
\Else
    \State Sends authentication request to the server with \verb|uid|
\EndIf
% C on (CltSession; sid; S; pw) ??
\State $x \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $X \gets g^x$

\If {OPRF}
    \State Wait to receive $e$, $Y$ and $h_2$ from the server
    \State $salt_2 \gets$ $h_2^{\frac{1}{r}}$
    \State $rw \gets$ Hash($salt_2$, $pw$)
    \State $(a, B) \gets$ Decrypt($rw$, $e$)
\Else
    \State Wait to receive $e$ and $Y$ from the server
    \State $(a, B) \gets$ Decrypt($pw$, $e$)
\EndIf

% HMQV :
% \State $d_c \gets$ Hash'(sid, C, S, 1, $X$)
% \State $e_c \gets$ Hash'(sid, C, S, 2, $Y$)
% \State $o_c \gets (Y \cdot B^{e_c})^{x+d_c \cdot a}$

% 3DH :
% \State $o_c \gets B^x || Y^a || Y^x$

% Generic
\State $o_c \gets$ KeyHidingAKE($X$, $Y$, $B$, $x$, $a$)

\State $k_1 \gets$ Hash(sid, C, S, $X$, $Y$, $o_c$)
\State $t_1 \gets$ PRF($k_1$, 1)
\State Sends $t_1$ and $X$ to the server


\State Wait to receive $t_2$ from the server
\If {$t_2 \neq$ PRF($k_1$, 2)}
    \State $K_1 \gets$ False
\Else
    \State $K_1 \gets$ PRF($k_1$, 0)
\EndIf

\State output $K_1$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{KHAPE : Authentication on the server (generic algorithm)}
\label{alg:login_server}
\begin{algorithmic}
\Require Store password file $file$ containing <$e$, $b$, $A$[, $salt$]>
\If {OPRF}
    \State Wait to receive authentication request from the client with \verb|uid| and $h_1$
\Else
    \State Wait to receive authentication request from the client with \verb|uid|
\EndIf

% S on (SvrSession; sid; C; uid)
\State $y \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $Y \gets g^y$

\If {OPRF}
    \State ($e$, $b$, $A$, $salt$) $\gets$ file[\verb|uid|, S] % TODO S ?
    \State $h_2 \gets h_1^{salt}$
    \State Sends $e$, $Y$ and $h_2$ to the client
\Else
    \State ($e$, $b$, $A$) $\gets$ file[\verb|uid|, S] % TODO S ?
    \State Sends $e$ and $Y$ to the client
\EndIf


\State Wait to receive $t_1$ and $X$ from the client

% 3DH :
% \State $o_s \gets X^b || A^y || X^y$

% Generic
\State $o_s \gets$ KeyHidingAKE($X$, $Y$, $A$, $y$, $b$)

\State $k_2 \gets$ Hash(sid, C, S, $X$, $Y$, $o_s$)


\If {$t_1 \neq$ PRF($k_2$, 1)}
    \State $t_2 \gets$ False
\Else
    \State $t_2 \gets$ PRF($k_2$, 2)
\EndIf


\State Sends $t_2$ to the client


\If {$t_1 \neq$ PRF($k_2$, 1)}
    \State $K_2 \gets$ False
\Else
    \State $K_2 \gets$ PRF($k_2$, 0)
\EndIf

\State output $K_2$
\end{algorithmic}
\end{algorithm}

% Notes:
% - x, y : ephemeral sessions secrets
% - a, b : long-term keys
% - d, e :  hashes of (session state identifiers and) resp. X = g^x and Y = g^y.

% To understand :
% - sid = Session identifiers (generated randomly for a new session)
% - uid = user id ?
% - C, S = each party identity ?? ("These identities could be e.g. domain names, user names, or any other identifiers. They have no other semantics except that the two parties can establish the same session key only if they assume matching identifiers, i.e. (P1; CP1) = (CP2; P2)")
% - CltSession
% - SvrSession


% TODO generate sid
% TODO C and S ?


\begin{algorithm}
\caption{KHAPE : Registration on the client (generic algorithm)}
\label{alg:register_client}
\begin{algorithmic}
\Require Choose username \verb|uid| and password $pw$

\If {OPRF}
    \State $r \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
    \State $h_1 \gets$ HashToGroup($pw$)$^r$
    \State Sends registration request to the server with \verb|uid| and $h_1$
\Else
    \State Sends registration request to the server with \verb|uid|
\EndIf

\State $a \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $A \gets g^a$

\If {OPRF}
    \State Wait to receive $B$ and $h_2$ from the server
    \State $salt_2 \gets$ $h_2^{\frac{1}{r}}$
    \State $rw \gets$ Hash($salt_2$, $pw$)
    \State $e \gets$ Encrypt($rw$, $(a, B)$)
\Else
    \State Wait to receive $B$ from the server
    \State $e \gets$ Encrypt($pw$, $(a, B)$)
\EndIf

\State Sends $e$ and $A$ to the server


\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{KHAPE : Registration on the server (generic algorithm)}
\label{alg:register_server}
\begin{algorithmic}
\Require 

\If {OPRF}
    \State Waits to receive registration request from a client with \verb|uid| and $h_1$
\Else
    \State Waits to receive registration request from a client with \verb|uid|
\EndIf

\State $b \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
\State $B \gets g^b$

\If {OPRF}
    \State $salt \gets$ GenerateRandomNumber in $\mathbb{Z}_p$
    \State $h_2 \gets h_1^{salt}$    
    \State Sends $B$ and $h_2$ to the client
\Else
    \State Sends $B$ to the client
\EndIf

\State Waits to receive $e$ and $A$ from the client

\If {OPRF}
    \State Store file[\verb|uid|, S] $\gets$ ($e$, $b$, $A$, $salt$) % TODO S ?
\Else
    \State Store file[\verb|uid|, S] $\gets$ ($e$, $b$, $A$) % TODO S ?
\EndIf

\end{algorithmic}
\end{algorithm}




\section{\writingFormulationBrut{Design choices}}

This section explain the design choices made to implement KHAPE.
Since the only resource for KHAPE is the rather theoretical paper, lots of design choice have to be made. However, since OPAQUE and KHAPE share similarities, some implementation choices are inspired by the OPAQUE standard draft whenever it's possible.





\subsection{\writingFormulationBrut{Client-side register}}
Both client-side and server-side registration are possible but in order to use the aPAKE benefit to the fullest, it is preferable to handle the registration on the client.
This allow to keep the main goal of aPAKEs: the server NEVER see the user's password.
For more details, see Section \ref{sec:opaque_register}.





\subsection{\writingFormulationBrut{Key Exchange}}
PAKE protocol compute a key exchange to perform authentication. The key exchange has to be authenticated to avoid attacks such as Man-in-the-Middle attacks that can be exploited on unauthenticated KE protocol like plain Diffie-Hellman.

In AKE protocols, each party has two asymmetric keys pair.
One long-term key pair that authenticate the exchange and one short-term (ephemeral) key pair that is used in the actual key exchange and only live for a single session.


KHAPE require that the underlying key exchange protocol is a ``key-hiding AKE'' (See Section \ref{sec:key_hiding_ake} for more details about this construction).
\cite{KHAPE_Paper} shows that HMQV, 3DH and SKEME are key-hiding AKE.

SKEME is a AKE based on key encryption mechanism where HMQV and 3DH are Diffie-Hellman based AKE.
\cite{OPAQUE_Paper} and \cite{KHAPE_Paper} shows concrete instantiation of their protocol using HMQV. These instantiations are easily adapted to other Diffie-Hellman based AKE like 3DH.

HMQV :
\begin{algorithmic}
 % HMQV :
\State $d_c \gets$ Hash'(sid, C, S, 1, $X$)
\State $e_c \gets$ Hash'(sid, C, S, 2, $Y$)
\State $o_c \gets (Y \cdot B^{e_c})^{x+d_c \cdot a}$
\end{algorithmic}

3DH :
\begin{algorithmic}
% 3DH :
\State $o_c \gets B^x || Y^a || Y^x$
\end{algorithmic}

Between 3DH and HMQV, the latter is more efficient but it is patented. This is why 3DH is used for the implementation.





\subsection{\writingFormulationBrut{Encryption scheme}}
KHAPE require that the encryption scheme is non-committing (See Section \ref{sec:non_committing_encryption}).

Non-committing encryption is archived by combining ideal cipher and curve encoding.

\paragraph{Ideal cipher.}
% What is IC
As its name may suggest, the ideal cipher model is an idealised model used to prove the security of cryptographical systems.

% Implementation (not implementable, but indstinguishable from IC)
In practice, an ideal cipher is not implementable % Pourquoi ?
but it's possible to construct an encryption scheme that is indifferentiable from an ideal cipher. Multiple constructions have been investigated in the literature.
The simplest construction is the one detailed in \cite{Ideal_Cipher_2} which is an update from \cite{Ideal_Cipher_1} that got broken.
The encryption scheme consist of 14 rounds of Feistel where function $F_i = H(key | i | input)$ \footnote{Thanks to Prof. Alexandre Duc for providing this construction}.

The hashing function must be large enough to receive half of the encryption envelope. Since this envelope store two group element, the hashing function must output 256 bits which is the size of a single group element.

In term of performance, this construction is not very efficient but its one of the only found that is easily instantiatiable.



\paragraph{Curve encoding.}
% What is it
The cleartext group elements that will be encrypted need to be encoded as a bitstring that is indistiguishable from random. This has the consequence that if plaintext is encrypted with password $pw$ and then decrypted with a different password $pw'$, the result is a random valid element.



% implementation (elligator)
This is done by implementing a quasi bijection from field elements to bitstrings.
Elligator-squared \cite{Elligator_Squared_Paper} and Elligator2 \cite{Elligator2_Paper} are implementation for such curve point encoding.
Both these constructions are suitable for the implementation of KHAPE but since the elliptic curve used is Curve25519, it is suitable for Elligator2.

\paragraph{Authentication.}
% no authentication
Authenticated encryption is generally recommended for encryption.
It is interesting to note that this encryption scheme must not be authenticated. 



In contrary to the OPAQUE Paper, the OPAQUE standard draft doesn't encrypt the client's private key in the envelope.
Instead, the envelope store a nonce of 32 bytes and an authentication tag. The envelope is not encrypted.
The nonce is used --- with the randomized password --- to compute a seed, which is then used to derive the client's private and public keys. The authentication tag stored in the envelope is used to verify the derived public key.





\subsection{\writingFormulationBrut{Group $\mathbb{G}$}}
The key exchange is computed on a group $\mathbb{G}$ of prime order $p$ with generator $g$.
The group is generic which means that we are free to use an integer group or an elliptic curves group.

For performances reasons, elliptic curves are used for the implementation (See Section \ref{sec:ecc_comparison}).
The curve must be compatible with the curve encoding algorithm selected (Elligator-squared, Elligator2, etc.).


For current usage, it is recommended to use 256 bits elliptic curve \cite{ECRYPT_Keylength}. For a more long-term usage (up to 50 years), it is recommended to use 512 bits elliptic curve.


For KHAPE implementation, curve25519 is used. It is a safe elliptic curve that provide the sufficient security level and is well suited for implementing Elligator2 on it.
Group element are represented on 32 bytes.




\subsection{\writingFormulationBrut{OPRF}} \label{sec:design_choice_oprf}
In KHAPE, the OPRF is optional --- in contrary to OPAQUE --- but allow to make it a strong aPAKE resistant against pre-computation attacks \ref{sec:secure_against_pca}.
This is a major improvement in term of security and therefore an OPRF should be used.

OPRF operations also need their own group and hashing function.
There is also an ongoing standard draft protocol for OPRF \cite{VOPRF_Standard_Draft} that present multiple ciphersuites for OPRF and different variants.
The OPRF used for the KHAPE implementation is based on this standard draft using the ristretto255-SHA-512 ciphersuite and the standard non-verifiable variant. % Why ?





\subsection{\writingFormulationBrut{Slow Hash}} \label{sec:design_choice_slowhash}
It is possible and recommended to use a memory-hard hashing function on the password to make it slow and expensive to compute. 
This make it more costly for an adversary to compute hashs.

For the implementation, Argon2id \cite{Argon2_Paper} is used because it is a recent memory-hard hashing function with a simple construction and it has better security analysis than others resource-heavy hashing function like scrypt, bcrypt and PBKDF2 \cite{CAA}. The Argon2id variant is used as it provide resistance against both GPU attacks and side-channel attacks --- and is the recommended version.

For OPAQUE, \cite{OPAQUE_Standard_Draft} propose to implement this function on the OPRF output $rw$ and use the result to derive the encryption key. Section \ref{sec:encryption_key} shows how this hashing function is used in the key derivation process.





\subsection{\writingFormulationBrut{Key derivation}}

This section describe the process of derivating keys from existing secrets. The design is heavily inspired by OPAQUE's standard draft \cite{OPAQUE_Standard_Draft} since the context is similar.


The primitive used to derive the encryption key, the export key, the output key and the key verification tags is HKDF \cite{HKDF_RFC}. It is well suited for expanding key from existing secret and is already used in OPAQUE rust's implementation \cite{OPAQUE_KE_lib}. It follows the ``Extract-then-Expand'' paradigm where these two functions are used with the following API :

\begin{itemize}
 \item Extract($salt$, $ikm$): Extract a fixed length pseudorandom key $prk$ with high entropy from the input keying material $ikm$ and the optional $salt$
 \item Expand($prk$, $info$, $L$): Expand the length of an existing pseudorandom key $prk$ with the optional string $info$ to produce an output keying material $okm$ of $L$ bytes.
\end{itemize}

HKDF is based on HMAC which in turn is based on an hashing function. The underlying hashing function used should output at least 256 bits to fit the group element size. SHA-3 256 is used for its robust design.



\subsubsection{Encryption key and export key}
\label{sec:encryption_key}

OPRF output --- or password --- is used to derive multiple keys with HKDF. The encryption key and the authentication key for computing authenticated encryption on the credential envelope. And the export key which is exposed at register and login and can be used by the application to encrypt application specific data. In Chapter \ref{cha:use_case}, it is shown how to use this key to encrypt user's passwords for an online password manager.

The following pseudo-code shows how these keys are derived.
\begin{algorithmic}
\Require $rw$ := OPRF output
\State $rw_{hardened}$ $\gets$ SlowHash($rw$)
\State $rw_{randomized}$ $\gets$ Extract(salt="", ikm=concat($rw$, $rw_{hardened}$))
\State $k_{encryption}$ $\gets$ Expand($rw_{randomized}$, "EncryptionKey", HashLength)
\State $k_{auth}$ $\gets$ Expand($rw_{randomized}$, "AuthKey", HashLength)
\State $k_{export}$ $\gets$ Expand($rw_{randomized}$, "ExportKey", HashLength)

\State Output $k_{encryption}$, $k_{auth}$ and $k_{export}$
\end{algorithmic}



% \begin{verbatim}
% 1. y = Finalize(password, blind, response.data, nil)
% 2. randomized_pwd = Extract("", concat(y, Harden(y, params)))
% \end{verbatim}
% 
% 
% \begin{verbatim}
% 2. masking_key = Expand(randomized_pwd, "MaskingKey", Nh)
% 3. auth_key = Expand(randomized_pwd, concat(envelope_nonce, "AuthKey"), Nh)
% 4. export_key = Expand(randomized_pwd, concat(envelope_nonce, "ExportKey"), Nh)
% 5. seed = Expand(randomized_pwd, concat(envelope_nonce, "PrivateKey"), Nseed)
% \end{verbatim}


\subsubsection{Output key and key verification}

HKDF is also used to compute the output key $K$ and both key verification tag $t_1$ and $t_2$.
Instead of exposing the handshake secret $k$ and computing each verification tag and the output key individually, these 3 values are computed at the same time and stored until needed.

The following pseudo-code shows how these keys are derived.
\begin{algorithmic}
\Require $o$ := AKE output, $preamble$ := protocol's identities and messages
\State $prk \gets$ Extract(salt="", ikm=$o$)

% \State $hss \gets$ Derive-Secret($prk$, "HandshakeSecret", Hash($preamble$))
% \State $k_{session} \gets$ Derive-Secret($prk$, "SessionKey", Hash($preamble$))
% \State $t_1 \gets$ Derive-Secret($hss$, "ClientMAC", "")
% \State $t_2 \gets$ Derive-Secret($hss$, "ServerMAC", "")

\State $k \gets$ Expand($prk$, concat("HandshakeSecret", Hash($preamble$)), HashLength)
\State $K \gets$ Expand($prk$, concat("SessionKey", Hash($preamble$)), HashLength)
\State $t_1 \gets$ Expand($k$, "ClientMAC", HashLength)
\State $t_2 \gets$ Expand($k$, "ServerMAC", HashLength)

\State Output $K$, $t_1$ and $t_2$
\end{algorithmic}

% \begin{verbatim}
% DeriveKeys(ikm, preamble)
% 
% Input:
% - ikm, input key material.
% - preamble, the protocol transcript with identities and messages.
% 
% Output:
% - Km2, a MAC authentication key.
% - Km3, a MAC authentication key.
% - session_key, the shared session secret.
% 
% Steps:
% 1. prk = Extract("", ikm)
% 2. handshake_secret = Derive-Secret(prk, "HandshakeSecret", Hash(preamble))
% 3. session_key = Derive-Secret(prk, "SessionKey", Hash(preamble))
% 4. Km2 = Derive-Secret(handshake_secret, "ServerMAC", "")
% 5. Km3 = Derive-Secret(handshake_secret, "ClientMAC", "")
% 6. Output (Km2, Km3, session_key)
% \end{verbatim}



\subsection{Session during authentication or registration ?}


\subsection{Hash}
Sha3-256

\subsection{HashToGroup}
Operation of hashing to the group. Since we use elliptic curves, this operation is an hash-to-curve.


\subsection{PRF}
HKDF



\subsection{GenerateRandomNumber}
Voir CAA





\section{\writingNotes{Limitations}}

In opposition with classical authentication method where the client only send an authentication request and receive a response. With KHAPE, the registration and the authentication processes require multiple messages (round-trip) between the client and the server.
This add new difficulties for both side that need to be considered.

\subsection{Client}
Necessity to send 2 messages. If the client is a web browser, he cannot only send a login form to the server. Behind the scenes request has to be made to compute the 2 round-trip. This means that some javascript has to be implemented but this was known from the beginning that PAKE protocol require a greater implication of the client (code-wise).

\subsection{Server}
Pre register secret, ephemeral key, session
The server communicate with multiple client at the same time so when a request come, he needs to know from which client/session it is from to be able to use the correct value. This is even more complicated because during both authentication and registration, the server generate some secret value in the first round trip and needs these values in the second round trip.



During authentication, the server needs to store his ephemeral private key for the second round-trip. He can store this value in the user's file entry or in a separated session file.

He can :
- Store this value in the file entry associated to the user
- Store this value in a session file entry (this require that client generate a session id and sends it with every request) (can be used to store session key later)
- Encrypt the value and send it to the client which send it back (like JWT)
In every case, the client has to resend the uid in the 2nd round-trip request

The second solution will be used. Allow multiple session
 


During register, the server generate his keys (private and public) and the secret salt. He sends the public key but the private key and the secret salt has to remain secret.

He can :
- Pre register the client in a incomplete file entry.
   - file[uid] = <secret\_salt, b, INCOMPLET>
   - file[uid] = <e, b, A, secret\_salt, COMPLET>
- Solution 2 and 3 from auth

The first solution will be used




\section{Security consideration}

\subsection{Difference with OPAQUE} %TODO put this section somewhere (in state-of-the-art ?)

Verification must be initialized by the client, this mean that protocol in completed with 4 message instead of 3 for OPAQUE.
Still use encryption (ideal cipher) where the OPAQUE standard draft doesn't use encryption anymore.
Use key-hiding AKE (3DH and HMQV are key-hiding AKE so this doesn't change anything).

% see OPAQUE standard chapter 10
\subsection{Input validation}
``We assume that parties verify public keys and ephemeral DH values, resp.
B; Y for P1 and A; X for P2, as group G elements.''

\subsection{SlowHash}
Optionaly, use Argon2, scrypt, etc. on the password before inputting it in the algo

\subsection{Session key usage}


\section{Precise algorithm}

\section{(Threat model)}



\end{document}

