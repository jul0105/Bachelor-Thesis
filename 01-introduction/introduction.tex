\documentclass[../report.tex]{subfiles}

\begin{document}

% 1. Summary of the problem
%     1. Classical auth methods(, vulnerability and attacks)
%     2. PAKE
% 2. Generalities
%     - Contexte du travail, volume d'heure, dates, temps plein, etc...


\chapter{\writingNotes{Introduction}}


% Order:

% Authentication
% 1. how to authenticate a user
% 2. attack and improvment (salt, KDF, pepper)
% 3. why password sucks (HW attack, logging, caching)
% 4. remove password (long term solution but need an alternative to secure password now)

% PAKE
% 5. PAKE at the rescue
% 6. Why PAKE have almost no adoption

% History of PAKE
% 7. Symmetric PAKE
% 8. Asymmetric PAKE and SRP
% 9. OPAQUE
% 10. KHAPE ?

\section{\writingNotes{Problematic}}
\subsection{\writingFormulationBrut{Authentication}}

\paragraph{\writingFormulationClean{How to authenticate a user ?}}

When a user want to connect itself to a online service, he send its username or email for identification. Then, he need a way to prove to the server that he is indeed the person he pretend to be. This is what we call authentication. Without it, anybody can impersonate the account of someone else.

Authentication can be based on multiple factors. Something that the user \emph{knows} (e.g. password, PIN, ...), something that the user \emph{has} (e.g. digital certificate, OTP token device, smartphone, ...) or something that the user \emph{is} (e.g. fingerprint, iris, ...). Multiple factors can be combined to obtain a strong authentication.

Traditionally, the user send the authentication value to the server through a secure channel --- generally TLS --- to avoid eavesdropping and then the server compare the value that he received to the value that he stored for the specific user.
This means that the server has to knows and store this sensible value before authentication --- generally during register.

Currently on the vast majority of websites and softwares, passwords are used as the authentication value. They are the easier to implement and the most familiar to the users.



\paragraph{\writingFormulationClean{Attacks and mitigations}}
This setup is not ideal and can lead to multiple attacks.
In case where the server get compromised, the attacker immediately obtain access to all passwords since the server store the passwords. This means that the adversary can impersonate every user.

To avoid this scenario, numerous technique has been developed.
Mainly, adding salt, adding pepper --- a secret salt --- and using memory-hard password hashing function such as Scrypt \cite{Scrypt_Paper} or Argon2 \cite{Argon2_Paper}.


These techniques improve the security of storing password but they doesn't address the deeper problem;
When the user wants to login, he has to send its \emph{cleartext} password to the server in order for the server to authenticate the user. This necessity void any password storing improvement if the server is ever persistently compromised or if passwords are accidentally logged or cached.


\paragraph{\writingFormulationClean{Why passwords are bad ?}}
Passwords are a problem. They are hard to remember and to manage for the user. They are generally low-entropy and users are reusing the same passwords too often. A password manager can help the client to handle this problem but there is a greater underlying problem.
The problem is that ``a password that leaves your possession is guaranteed to sacrifice security, no matter its complexity or how hard it may be to guess. Passwords are insecure by their very existence'' \cite{PAKE_Cloudflare_blog}. % cite
Now-a-day, majority of password use require that the password is sent in cleartext.

Even if the channel between the client and the server is appropriately secured, generally with TLS (PKI attack, cert miss-configuration, etc.), % TODO
and even if on the server-side every secure password storing techniques are implemented, the password still has to be processed in cleartext.
As stated before, there can be some software issue like accidental logging or caching of the password. But hardware vulnerabilities are not to forgot. While the password is processed in clear, it reside on the memory. It use a shared bus between the CPU and the memory. Hardware attacks are less likely to occur but are no less severe (remember Spectre and Meltdown). % TODO cite

In a ideal world, the server should never see the user's password in cleartext at all.


\paragraph{\writingFormulationBrut{Get rid of password}}

In summary, password are not ideal. They are difficult to remember, annoying to type and insecure.
So why don't we try to get rid of them altogether ?

Promising initiatives to reduce or remove passwords are emerging and improving. % (TODO examples: WebAuthn).

% TODO utiliser what we have and what we are. pas simple pour l'utilisateur final
% TODO Expliquer que utiliser des clé publique pour s'auth, c'est pas très pratique. Par exemple si on change d'ordi, ou en déplacement.
These solutions are a good replacement to passwords but they require a deep change. It will take time for them to grow mature and impose themself as industry standard.
This is also because password are so ubiquitous due in part to the ease of implementation and the familiarity for the users.
If we cannot get rid of passwords for now, we need a way to make it ``as secure as possible while they persist''. % TODO cite


This is where PAKE become interesting. It allow password-based authentication without the password leaving the client.




\subsection{\writingNotes{Password-Authenticated Key Exchange}}
\paragraph{\writingNotes{PAKEs at the rescue}}

% Password-Authentication Key Exchange (PAKE) are cryptographic primitive that allow a server to authenticate a client without ever knowing or storing client's password.
% 
% Password-authenticated key exchange (PAKE) are very powerful cryptographic primitive. They allow a server to share a key with a client or to authenticate a client without having to know or to store his password.
% For this reason, they provide better security guarantees for initializing a secure connection using password than usual mechanism where the password is transmitted to the server and then compared to a hash.


% PAKE at the rescue :

% (PAKE "provide protection for the client's password")
% "A stronger version of this guarantee can be stated as follows: after a login attempt (valid, or invalid) both the client and server should learn only whether the client’s password matched the server’s expected value, and no additional information. This is a powerful guarantee. In fact, it’s not dissimilar to what we ask for from a zero knowledge proof"
% PAKE allow to .........

% "many people dont want to run a key exchange protocol. They just want to verify that a user knows a password."
% "The great thing about PAKE is that the simpler “login only” use-case is easy to achieve. If I have a standard PAKE protocol that allows a client and server to agree on a shared key K if (and only if) the client knows the right password, then all we need add is a simple check that both parties have arrived at the same key."

% symmetric PAKE
% asymmetric PAKE

% "password auth and mutually auth key exchange in a client-server setting without relying on PKI (expect during registration)"
% "Without disclosing passwords to servers or other entities other than the client machine."
% "A secure aPAKE should provide the best possible security for a password protocol"
% only vulnerable to inevitable attacks (online guess or offline dictionary attacks if server's data get leaked)
% PKI-free

Password-Authenticated Key Exchange (PAKE) is a cryptographic primitive. There is two types of PAKEs: 

\begin{itemize}
 \item Symmetric (also known as balanced) PAKE where the two party knows the password in clear
 \item Asymmetric (also known as augmented) PAKE designed for client-server scenarios. Only the client knows the password in clear
\end{itemize}

For the moment, we will focus on asymmetric PAKE (aPAKE) because it is the one that can solve our authentication problem.

aPAKE guarantee that the client's password is protected because it never leave the client's machine in cleartext.
It is done by doing a key exchange between the client and the server.
%In majority of case, the server doesn't want to setup a key exchange with the client, he just want to authenticate the client.
It allow mutual authentication in a client-server scenarios without requiring a PKI (except for the initial registration).

``A secure aPAKE should provide the best possible security for a password protocol'' \cite{OPAQUE_Standard_Draft}.

And should only be vulnerable to inevitable attacks such as online guess or offline dictionary attacks if server's data get leaked.

\paragraph{\writingFormulationBrut{Why PAKEs have almost no adoption ?}}

% Why PAKE have almost no adoption :

% PAKE provides "an obvious security benefit compared to the naive approach we use to log into servers today." 
% PAKE are old. "they have been known since 1992"

% "Almost no adoption"
% "it's much easier to put a password form onto a web page than it is to do dancy crypto in the browser"
% But "even native app rarely implement PAKE for their logins"

% patents ("though most of these are expired now")
% "Lack of good PAKE implementations in useful languages". "Make them a hassle to use"
% few exceptions (SRP)
% new generation, getting better, standards


Despite existing for nearly 3 decades and providing better security guanrantees than traditional authentication method, PAKEs have almost no adoption. So why are they so rare in the industry now-a-day ?

Firstly, for web site, it's easier to setup a password form and handle all the processing on the server than to implement complex cryptography in the browser. But even in native app PAKEs are rarely used to authenticate.

This could be caused by the fact that many old PAKEs was either patented, got broken or both. % TODO need example
It probably hurted the reputation and adoption of PAKEs.
Another factor is the insufficiency of well-implemented PAKE library in some programming language % TODO example ?
which make them difficult to use.

One exception to that is SRP, the most used PAKE protocol in the world. % TODO cite Green ? "most widely-deployed PAKE in the world"
 It is a TLS ciphersuite, is implemented in OpenSSL and used in Apple's iCloud Key Vault. Even though it has far more adoption than other PAKEs, is not the ideal PAKE.


Today, new generation of PAKE are better and provide more security guarantees. Efforts are made to make PAKE a standard for password authentication. % TODO cite OPAQUE standard ?



% - "most wiidely-deployed PAKE protocol in the world"
% - TLS ciphersuite, implemented in OpenSSL
% - used extensively in iCloud Key Vault ("make SRP one of the most widely used cryptographic protocols in the world, so vast is the number of devices that Apple ships. So this is nothing to sneer at")
% - "SRP isn't the best PAKE we can deploy"


\section{My contribution}
\end{document}

